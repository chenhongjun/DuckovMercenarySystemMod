# Unity场景间角色复制重建技术文档

## 概述

本文档基于《逃离鸭科夫》联机Mod的实现，详细说明如何在一个场景（Scene A）中复制已有角色对象，并在另一个场景（Scene B）中重新构建该角色的完整方法。

## 目录

1. [核心策略](#核心策略)
2. [实现流程](#实现流程)
3. [关键API与参数](#关键api与参数)
4. [代码实现示例](#代码实现示例)
5. [注意事项与最佳实践](#注意事项与最佳实践)

---

## 核心策略

### 1. 数据序列化策略

角色对象无法直接跨场景传递，需要将角色的**状态数据**序列化为可传输的格式：

- **位置与旋转**：`Vector3` + `Quaternion`
- **外观数据**：自定义面部配置（JSON格式）
- **装备数据**：装备槽位与物品ID映射
- **武器数据**：武器槽位与物品ID映射
- **物品树**：完整的物品层级结构（包含附件、容器内容等）
- **场景标识**：目标场景ID（`SceneId`）

### 2. 重建策略

在新场景中重建角色采用**模板克隆 + 状态还原**的方式：

1. **克隆模板对象**：使用本地玩家对象作为模板
2. **禁用本地控制**：关闭物理、AI、输入等本地驱动组件
3. **应用序列化数据**：将保存的状态数据还原到新对象
4. **网络驱动**：通过网络数据驱动位置、动画等

---

## 实现流程

### 阶段一：场景切换前的数据采集

#### 1.1 采集角色状态快照

```csharp
// 位置和旋转
Vector3 position = CharacterMainControl.Main.transform.position;
Quaternion rotation = CharacterMainControl.Main.modelRoot.transform.rotation;

// 场景ID
string sceneId;
LocalPlayerManager.Instance.ComputeIsInGame(out sceneId);

// 外观数据（JSON）
string customFaceJson = CustomFace.LoadLocalCustomFaceJson();

// 装备数据
List<EquipmentSyncData> equipmentList = LocalPlayerManager.Instance.GetLocalEquipment();

// 武器数据
List<WeaponSyncData> weaponList = LocalPlayerManager.Instance.GetLocalWeapons();

// 物品树快照（完整物品数据）
ItemSnapshot itemSnapshot = ItemTool.MakeSnapshot(CharacterMainControl.Main.CharacterItem);
```

#### 1.2 序列化数据打包

```csharp
// 使用 NetDataWriter 打包数据
NetDataWriter writer = new NetDataWriter();
writer.Put((byte)Op.SCENE_READY);  // 操作码
writer.Put(playerId);               // 玩家ID
writer.Put(sceneId);                // 场景ID
writer.PutVector3(position);        // 位置
writer.PutQuaternion(rotation);     // 旋转
writer.Put(customFaceJson);         // 外观JSON

// 装备数据
writer.Put(equipmentList.Count);
foreach (var eq in equipmentList)
{
    writer.Put(eq.SlotHash);        // 槽位哈希
    writer.Put(eq.ItemId);          // 物品ID
}

// 武器数据
writer.Put(weaponList.Count);
foreach (var wp in weaponList)
{
    writer.Put(wp.SlotHash);
    writer.Put(wp.ItemId);
}

// 物品树快照（递归序列化）
ItemTool.WriteItemSnapshot(writer, CharacterMainControl.Main.CharacterItem);
```

### 阶段二：场景切换与数据传递

#### 2.1 场景加载流程

```csharp
// 1. 发起场景投票（主机）
SceneNet.Instance.Host_BeginSceneVote_Simple(
    targetSceneId: "SceneB",           // 目标场景ID
    curtainGuid: null,                 // 过场动画GUID（可选）
    notifyEvac: false,                 // 是否通知撤离
    saveToFile: true,                  // 是否保存到文件
    useLocation: false,                // 是否使用位置
    locationName: ""                   // 位置名称
);

// 2. 等待所有玩家准备就绪
// 3. 主机广播开始加载
SceneNet.Instance.Server_BroadcastBeginSceneLoad();

// 4. 执行本地场景加载
SceneLoaderProxy proxy = FindObjectOfType<SceneLoaderProxy>();
if (proxy != null && proxy.sceneID == targetSceneId)
{
    proxy.LoadScene();
}
```

#### 2.2 场景门控机制（Gate System）

确保所有玩家加载完成后再开始游戏：

```csharp
// 客户端：场景加载完成后上报就绪
public async UniTask Client_SceneGateAsync()
{
    // 1. 等待连接建立
    while (connectedPeer == null && Time.realtimeSinceStartup < deadline)
        await UniTask.Delay(100);
    
    // 2. 上报场景就绪
    writer.Reset();
    writer.Put((byte)Op.SCENE_GATE_READY);
    writer.Put(playerId);
    writer.Put(sceneId);
    connectedPeer.Send(writer, DeliveryMethod.ReliableOrdered);
    
    // 3. 等待主机放行
    while (!_cliSceneGateReleased && Time.realtimeSinceStartup < deadline)
    {
        SceneLoader.LoadingComment = "等待主机...";
        await UniTask.Delay(100);
    }
}

// 主机：所有客户端就绪后放行
public async UniTask Server_SceneGateAsync()
{
    // 1. 等待所有客户端上报就绪
    while (Time.realtimeSinceStartup < deadline)
        await UniTask.Delay(100);
    
    // 2. 放行所有已就绪的客户端
    foreach (var peer in readyPeers)
    {
        writer.Reset();
        writer.Put((byte)Op.SCENE_GATE_RELEASE);
        writer.Put(sceneId);
        peer.Send(writer, DeliveryMethod.ReliableOrdered);
    }
}
```

### 阶段三：新场景中的角色重建

#### 3.1 接收场景就绪消息

```csharp
// 主机处理客户端场景就绪
public void Server_HandleSceneReady(
    NetPeer fromPeer, 
    string playerId, 
    string sceneId, 
    Vector3 pos, 
    Quaternion rot, 
    string faceJson)
{
    // 1. 记录玩家所在场景
    SceneM._srvPeerScene[fromPeer] = sceneId;
    
    // 2. 向新进入的玩家发送同场景其他玩家的创建指令
    foreach (var kv in SceneM._srvPeerScene)
    {
        if (kv.Value == sceneId && kv.Key != fromPeer)
        {
            var otherPlayer = playerStatuses[kv.Key];
            var w = new NetDataWriter();
            w.Put((byte)Op.REMOTE_CREATE);
            w.Put(otherPlayer.EndPoint);
            w.Put(sceneId);
            w.PutVector3(otherPlayer.Position);
            w.PutQuaternion(otherPlayer.Rotation);
            w.Put(otherPlayer.CustomFaceJson);
            fromPeer.Send(w, DeliveryMethod.ReliableOrdered);
        }
    }
    
    // 3. 向同场景其他玩家广播新玩家进入
    // 4. 向不同场景的玩家发送移除指令
}
```

#### 3.2 创建远程角色对象

```csharp
public static async UniTask CreateRemoteCharacterForClient(
    string playerId, 
    Vector3 position, 
    Quaternion rotation, 
    string customFaceJson)
{
    // 1. 检查是否已存在
    if (clientRemoteCharacters.ContainsKey(playerId) && 
        clientRemoteCharacters[playerId] != null) 
        return;
    
    // 2. 验证场景管理器
    var levelManager = LevelManager.Instance;
    if (levelManager == null || levelManager.MainCharacter == null) 
        return;
    
    // 3. 克隆本地玩家对象作为模板
    var instance = GameObject.Instantiate(
        CharacterMainControl.Main.gameObject, 
        position, 
        rotation
    );
    
    var characterModel = instance.GetComponent<CharacterMainControl>();
    
    // 4. 加载基础物品数据
    var itemLoaded = await ItemSavesUtilities.LoadItem(
        LevelManager.MainCharacterItemSaveKey
    );
    if (itemLoaded == null)
    {
        itemLoaded = await ItemAssetsCollection.InstantiateAsync(
            GameplayDataSettings.ItemAssets.DefaultCharacterItemTypeID
        );
    }
    
    // 5. 设置角色物品
    Traverse.Create(characterModel)
        .Field<Item>("characterItem")
        .Value = itemLoaded;
    
    // 6. 清除手持物品
    COOPManager.StripAllHandItems(characterModel);
    
    // 7. 设置初始位姿
    instance.transform.SetPositionAndRotation(position, rotation);
    
    // 8. 禁用物理和AI系统
    MakeRemotePhysicsPassive(instance);
    
    // 9. 应用外观数据
    CustomFace.StripAllCustomFaceParts(instance);
    if (!string.IsNullOrEmpty(customFaceJson))
    {
        CustomFace.Client_ApplyFaceIfAvailable(playerId, instance, customFaceJson);
    }
    
    // 10. 清除装备（后续通过网络同步）
    var cm = characterModel.characterModel;
    COOPManager.ChangeArmorModel(cm, null);
    COOPManager.ChangeHelmatModel(cm, null);
    COOPManager.ChangeFaceMaskModel(cm, null);
    COOPManager.ChangeBackpackModel(cm, null);
    COOPManager.ChangeHeadsetModel(cm, null);
    
    // 11. 添加远程标识
    instance.AddComponent<RemoteReplicaTag>();
    
    // 12. 配置动画系统
    var anim = instance.GetComponentInChildren<Animator>(true);
    if (anim)
    {
        anim.cullingMode = AnimatorCullingMode.AlwaysAnimate;
        anim.updateMode = AnimatorUpdateMode.Normal;
        anim.applyRootMotion = false;
    }
    
    // 13. 配置血量系统
    var h = instance.GetComponentInChildren<Health>(true);
    if (h) h.autoInit = false;
    instance.AddComponent<AutoRequestHealthBar>();
    
    // 14. 挂载网络插值组件
    NetInterpUtil.Attach(instance)?.Push(position, rotation);
    AnimInterpUtil.Attach(instance);
    
    // 15. 注册到字典
    characterModel.gameObject.SetActive(false);
    clientRemoteCharacters[playerId] = instance;
    characterModel.gameObject.SetActive(true);
}
```

#### 3.3 禁用物理系统

```csharp
private static void MakeRemotePhysicsPassive(GameObject go)
{
    // 1. 禁用AI控制器
    var ai = go.GetComponentInChildren<AICharacterController>(true);
    if (ai) ai.enabled = false;
    
    // 2. 禁用导航网格代理
    var nma = go.GetComponentInChildren<NavMeshAgent>(true);
    if (nma) nma.enabled = false;
    
    // 3. 禁用角色控制器
    var cc = go.GetComponentInChildren<CharacterController>(true);
    if (cc) cc.enabled = false;
    
    // 4. 设置刚体为运动学
    var rb = go.GetComponentInChildren<Rigidbody>(true);
    if (rb)
    {
        rb.isKinematic = true;
        rb.velocity = Vector3.zero;
        rb.angularVelocity = Vector3.zero;
    }
    
    // 5. 禁用根运动
    var anim = go.GetComponentInChildren<Animator>(true);
    if (anim) anim.applyRootMotion = false;
    
    // 6. 禁用其他移动相关组件
    foreach (var mb in go.GetComponentsInChildren<MonoBehaviour>(true))
    {
        var name = mb.GetType().Name;
        if (name.Contains("Locomotion") || 
            name.Contains("Movement") || 
            name.Contains("Motor"))
        {
            var beh = mb as Behaviour;
            if (beh) beh.enabled = false;
        }
    }
}
```

#### 3.4 应用装备和武器

```csharp
// 应用装备更新
public async UniTask ApplyEquipmentUpdate_Client(
    string playerId, 
    int slotHash, 
    string itemId)
{
    if (!clientRemoteCharacters.TryGetValue(playerId, out var go) || go == null)
        return;
    
    var cmc = go.GetComponent<CharacterMainControl>();
    if (cmc == null) return;
    
    var model = cmc.characterModel;
    if (model == null) return;
    
    // 根据槽位哈希确定装备类型
    Item item = null;
    if (!string.IsNullOrEmpty(itemId) && int.TryParse(itemId, out var itemTypeId))
    {
        item = await COOPManager.GetItemAsync(itemTypeId);
    }
    
    // 应用装备到对应槽位
    if (slotHash == CharacterEquipmentController.armorHash)
        COOPManager.ChangeArmorModel(model, item);
    else if (slotHash == CharacterEquipmentController.helmatHash)
        COOPManager.ChangeHelmatModel(model, item);
    else if (slotHash == CharacterEquipmentController.faceMaskHash)
        COOPManager.ChangeFaceMaskModel(model, item);
    else if (slotHash == CharacterEquipmentController.backpackHash)
        COOPManager.ChangeBackpackModel(model, item);
    else if (slotHash == CharacterEquipmentController.headsetHash)
        COOPManager.ChangeHeadsetModel(model, item);
}

// 应用武器更新
public async UniTask ApplyWeaponUpdate_Client(
    string playerId, 
    int slotHash, 
    string itemId)
{
    if (!clientRemoteCharacters.TryGetValue(playerId, out var go) || go == null)
        return;
    
    var cmc = go.GetComponent<CharacterMainControl>();
    if (cmc == null) return;
    
    var model = cmc.characterModel;
    if (model == null) return;
    
    Item item = null;
    if (!string.IsNullOrEmpty(itemId) && int.TryParse(itemId, out var itemTypeId))
    {
        item = await COOPManager.GetItemAsync(itemTypeId);
    }
    
    // 根据槽位类型应用武器
    HandheldSocketTypes socketType = (HandheldSocketTypes)slotHash;
    COOPManager.ChangeWeaponModel(model, item, socketType);
}
```

---

## 关键API与参数

### 1. 场景管理API

#### `SceneNet.Instance.TrySendSceneReadyOnce()`
**功能**：上报当前场景就绪状态  
**参数**：无  
**返回值**：void  
**说明**：自动检测场景ID，只在真正进入地图时上报一次

#### `SceneNet.Instance.Host_BeginSceneVote_Simple()`
**功能**：主机发起场景切换投票  
**参数**：
- `targetSceneId` (string): 目标场景ID
- `curtainGuid` (string): 过场动画GUID（可选）
- `notifyEvac` (bool): 是否通知撤离
- `saveToFile` (bool): 是否保存到文件
- `useLocation` (bool): 是否使用位置
- `locationName` (string): 位置名称

#### `LocalPlayerManager.Instance.ComputeIsInGame()`
**功能**：计算当前是否在游戏中并获取场景ID  
**参数**：
- `out sceneId` (string): 输出场景ID

**返回值**：bool（是否在游戏中）

### 2. 数据序列化API

#### `ItemTool.MakeSnapshot(Item item)`
**功能**：创建物品快照（递归包含所有子物品）  
**参数**：
- `item` (Item): 要序列化的物品对象

**返回值**：`ItemSnapshot` 结构体

**ItemSnapshot结构**：
```csharp
public struct ItemSnapshot
{
    public int typeId;                                    // 物品类型ID
    public int stack;                                     // 堆叠数量
    public float durability;                              // 耐久度
    public float durabilityLoss;                           // 耐久损失
    public bool inspected;                                 // 是否已检查
    public List<(string key, ItemSnapshot child)> slots;  // 附件槽位
    public List<ItemSnapshot> inventory;                   // 容器内容
}
```

#### `ItemTool.WriteItemSnapshot(NetDataWriter w, Item item)`
**功能**：将物品快照写入网络数据流  
**参数**：
- `w` (NetDataWriter): 网络数据写入器
- `item` (Item): 要序列化的物品

**写入格式**：
```
[TypeID: int]
[StackCount: int]
[Durability: float]
[DurabilityLoss: float]
[Inspected: bool]
[SlotsCount: ushort]
  [SlotKey: string]
  [SlotItem: ItemSnapshot (递归)]
[InventoryCount: ushort]
  [InventoryItem: ItemSnapshot (递归)]
```

#### `ItemTool.ReadItemSnapshot(NetPacketReader r)`
**功能**：从网络数据流读取物品快照  
**参数**：
- `r` (NetPacketReader): 网络数据读取器

**返回值**：`ItemSnapshot`

#### `ItemTool.BuildItemFromSnapshot(ItemSnapshot s)`
**功能**：从快照重建物品对象  
**参数**：
- `s` (ItemSnapshot): 物品快照

**返回值**：`Item` 对象

**说明**：异步加载物品资源，递归重建所有子物品

### 3. 角色创建API

#### `CreateRemoteCharacter.CreateRemoteCharacterForClient()`
**功能**：在客户端创建远程玩家对象  
**参数**：
- `playerId` (string): 玩家唯一标识
- `position` (Vector3): 初始位置
- `rotation` (Quaternion): 初始旋转
- `customFaceJson` (string): 外观JSON数据

**返回值**：`UniTask`（异步任务）

#### `CreateRemoteCharacter.CreateRemoteCharacterAsync()`
**功能**：在主机端创建远程玩家对象  
**参数**：
- `peer` (NetPeer): 网络对等体
- `position` (Vector3): 初始位置
- `rotation` (Quaternion): 初始旋转
- `customFaceJson` (string): 外观JSON数据

**返回值**：`UniTask<GameObject>`

### 4. 外观系统API

#### `CustomFace.LoadLocalCustomFaceJson()`
**功能**：加载本地玩家外观配置  
**返回值**：string（JSON格式的外观数据）

#### `CustomFace.Client_ApplyFaceIfAvailable()`
**功能**：应用外观数据到角色对象  
**参数**：
- `playerId` (string): 玩家ID
- `instance` (GameObject): 角色对象
- `customFaceJson` (string): 外观JSON

### 5. 装备系统API

#### `COOPManager.ChangeArmorModel()`
**功能**：更换角色护甲模型  
**参数**：
- `characterModel` (CharacterModel): 角色模型
- `item` (Item): 护甲物品（null表示移除）

#### `COOPManager.ChangeHelmatModel()`
**功能**：更换头盔模型

#### `COOPManager.ChangeWeaponModel()`
**功能**：更换武器模型  
**参数**：
- `characterModel` (CharacterModel): 角色模型
- `item` (Item): 武器物品
- `handheldSocket` (HandheldSocketTypes): 手持槽位类型

### 6. 网络插值API

#### `NetInterpUtil.Attach(GameObject go)`
**功能**：为对象挂载网络位置插值组件  
**参数**：
- `go` (GameObject): 目标对象

**返回值**：`NetInterpolator` 组件

#### `NetInterpolator.Push(Vector3 position, Quaternion rotation)`
**功能**：推送新的位置和旋转数据  
**参数**：
- `position` (Vector3): 目标位置
- `rotation` (Quaternion): 目标旋转

#### `AnimInterpUtil.Attach(GameObject go)`
**功能**：为对象挂载动画参数插值组件  
**返回值**：`AnimParamInterpolator` 组件

---

## 代码实现示例

### 完整示例：场景切换与角色重建

```csharp
// ===== 场景A：采集角色数据 =====
public void OnSceneSwitchRequest(string targetSceneId)
{
    // 1. 采集角色状态
    var main = CharacterMainControl.Main;
    var position = main.transform.position;
    var rotation = main.modelRoot.transform.rotation;
    
    string sceneId;
    LocalPlayerManager.Instance.ComputeIsInGame(out sceneId);
    
    var customFaceJson = CustomFace.LoadLocalCustomFaceJson();
    var equipmentList = LocalPlayerManager.Instance.GetLocalEquipment();
    var weaponList = LocalPlayerManager.Instance.GetLocalWeapons();
    var itemSnapshot = ItemTool.MakeSnapshot(main.CharacterItem);
    
    // 2. 打包数据
    var writer = new NetDataWriter();
    writer.Put((byte)Op.SCENE_READY);
    writer.Put(NetService.Instance.GetPlayerId(null));
    writer.Put(sceneId);
    writer.PutVector3(position);
    writer.PutQuaternion(rotation);
    writer.Put(customFaceJson ?? "");
    
    // 发送到主机
    NetService.Instance.connectedPeer?.Send(writer, DeliveryMethod.ReliableOrdered);
    
    // 3. 发起场景切换投票
    SceneNet.Instance.Client_RequestBeginSceneVote(
        targetSceneId, null, false, true, false, ""
    );
}

// ===== 场景B：接收并重建角色 =====
public void OnNetworkReceive(NetPeer peer, NetPacketReader reader, ...)
{
    var op = (Op)reader.GetByte();
    
    switch (op)
    {
        case Op.REMOTE_CREATE:
            // 读取创建数据
            var playerId = reader.GetString();
            var sceneId = reader.GetString();
            var pos = reader.GetVector3();
            var rot = reader.GetQuaternion();
            var faceJson = reader.GetString();
            
            // 检查是否在同一场景
            string mySceneId;
            LocalPlayerManager.Instance.ComputeIsInGame(out mySceneId);
            
            if (sceneId == mySceneId)
            {
                // 创建远程角色
                CreateRemoteCharacter.CreateRemoteCharacterForClient(
                    playerId, pos, rot, faceJson
                ).Forget();
            }
            break;
            
        case Op.EQUIPMENT_UPDATE:
            // 应用装备更新
            var eqPlayerId = reader.GetString();
            var slotHash = reader.GetInt();
            var itemId = reader.GetString();
            
            COOPManager.ClientPlayer_Apply.ApplyEquipmentUpdate_Client(
                eqPlayerId, slotHash, itemId
            ).Forget();
            break;
            
        case Op.PLAYERWEAPON_UPDATE:
            // 应用武器更新
            var wpPlayerId = reader.GetString();
            var wpSlotHash = reader.GetInt();
            var wpItemId = reader.GetString();
            
            COOPManager.ClientPlayer_Apply.ApplyWeaponUpdate_Client(
                wpPlayerId, wpSlotHash, wpItemId
            ).Forget();
            break;
    }
}
```

---

## 注意事项与最佳实践

### 1. 场景切换时机

- **确保场景完全加载**：使用场景门控（Gate）机制，等待所有玩家加载完成
- **避免竞态条件**：使用场景ID验证，确保只在同一场景中创建角色
- **处理异步加载**：物品资源加载是异步的，使用 `await` 或 `UniTask`

### 2. 数据完整性

- **递归序列化**：物品树包含附件和容器内容，必须递归序列化
- **空值处理**：装备槽位可能为空，需要处理 `null` 情况
- **数据验证**：接收数据后验证有效性，避免崩溃

### 3. 性能优化

- **延迟创建**：只在玩家进入同一场景时创建远程对象
- **对象池**：考虑复用已销毁的远程角色对象
- **按需加载**：装备和武器按需异步加载，避免阻塞

### 4. 网络同步

- **可靠传输**：场景切换相关消息使用 `DeliveryMethod.ReliableOrdered`
- **去重机制**：使用字典检查，避免重复创建
- **超时处理**：设置合理的超时时间，避免无限等待

### 5. 错误处理

```csharp
try
{
    var item = await COOPManager.GetItemAsync(itemTypeId);
    if (item == null)
    {
        Debug.LogWarning($"物品加载失败: {itemTypeId}");
        return; // 使用默认物品或跳过
    }
    // 应用物品
}
catch (Exception ex)
{
    Debug.LogError($"应用物品异常: {ex.Message}");
    // 回退到安全状态
}
```

### 6. 内存管理

- **及时销毁**：场景切换时销毁旧场景的远程对象
- **引用清理**：从字典中移除已销毁对象的引用
- **资源释放**：临时创建的物品对象使用后及时销毁

```csharp
// 场景切换时清理
foreach (var kvp in clientRemoteCharacters)
{
    if (kvp.Value != null)
        Destroy(kvp.Value);
}
clientRemoteCharacters.Clear();
```

---

## 总结

场景间角色复制重建的核心流程：

1. **数据采集** → 序列化角色状态（位置、外观、装备、物品树）
2. **场景切换** → 使用场景门控确保同步加载
3. **数据传递** → 通过网络发送创建指令
4. **对象重建** → 克隆模板 + 应用状态数据
5. **网络驱动** → 禁用本地控制，由网络数据驱动

关键点：
- ✅ 使用模板克隆而非直接传递GameObject
- ✅ 完整的状态序列化（包含递归物品树）
- ✅ 场景门控确保同步
- ✅ 异步资源加载避免阻塞
- ✅ 网络插值平滑显示

---

**文档版本**：v1.0  
**最后更新**：2025-01-27  
**参考项目**：Escape-From-Duckov-Coop-Mod-Preview

