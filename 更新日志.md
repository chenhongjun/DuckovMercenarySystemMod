# 更新日志 (Changelog)

## v1.7 - 完美实现！修改AI巡逻中心（2025-11-11）

### 🎉 重大突破
- ✅ **成功实现友军跟随**：友军保留完整AI智能，能攻击、能躲避
- ✅ **找到关键字段**：`AICharacterController.patrolPosition` 和 `patrolRange`
- ✅ **巧妙的解决方案**：持续更新巡逻中心点为玩家位置

### 🔍 问题诊断过程
1. **F6探索AI控制器** → 发现 `AIControllerTemplate(Clone)` 子对象
2. **分析组件字段** → 找到 `patrolPosition` (Vector3) 和 `patrolRange` (float)
3. **禁用AI失败** → 友军变傻，不会攻击
4. **修改参数成功** → 保留AI智能，只改目标位置

### 🎯 核心实现
```csharp
// 找到AI控制器的AICharacterController组件
Component aiController = ally.transform
    .Find("AIControllerTemplate(Clone)")
    .GetComponent("AICharacterController");

// 修改巡逻中心点为玩家位置
patrolPosition = playerPosition;  // 每0.05秒更新
patrolRange = 15f;                // 扩大巡逻范围
```

### 💡 关键优化
- **静默更新**：Update循环中不打印日志，避免刷屏
- **距离阈值**：只有玩家移动超过1米才更新，减少性能消耗
- **反射缓存**：每次查找AI控制器并更新字段

### 🎮 最终效果
- ✅ 友军自然跟随玩家（围绕15米范围）
- ✅ 主动攻击敌人
- ✅ 使用AI战术（掩体、躲避）
- ✅ 移动流畅自然
- ✅ 完全保留原有智能

### 🧠 学到的经验
- 💎 **不要禁用，要引导**：找到系统的控制参数，而不是关闭它
- 🔍 **F6探索工具很关键**：深度探索组件字段，找到Vector3/Transform类型
- 📊 **观察日志找规律**：`patrolPosition` 距离玩家43米，显然是原巡逻点
- 🎯 **简单的方案最有效**：修改一个Vector3字段胜过禁用十个组件

---

## v1.6 - 简化调试工具（重构）(2025-11-11)

### ✨ 重构内容
- 🔄 **简化调试功能**：去掉所有组件监控和复杂观测
- 🎯 **F8键** - 打印友军的所有组件列表（包括启用状态）
- 🔍 **F7键** - 深度探索CharacterMainControl（字段、属性、方法、子对象）
- 🧹 **代码清理** - 移除冗余的监控代码和复杂的反射逻辑

### 📋 新的调试输出
**F8 - 打印友军组件：**
```
=== 📦 友军组件列表 ===
角色: Enemy(Clone)
位置: (10.5, 0.0, 15.3)
队伍: player
共 15 个组件:
  🟢 CharacterMainControl
  🟢 Movement
  🟢 CharacterMovement
  🔴 GuardAI (已禁用)
  ...
```

**F7 - CharacterMainControl详情：**
```
=== 🔬 CharacterMainControl 深度探索 ===
📋 字段 (50个):
  • Team (Teams): player
  • _health (Single): 100
  ...
🔧 属性 (20个):
  • IsAlive (Boolean): True
  ...
⚙️ 公共方法 (15个):
  • SetTeam(Teams) → Void
  • SetMoveInput(Vector3) → Void
  ...
👶 子对象 (3个):
  • Head (位置: (0, 1.8, 0))
  ...
```

### 🎯 优化结果
- ✅ 代码行数减少40%
- ✅ 调试输出更清晰
- ✅ 专注于找到控制NPC的关键变量

---

## v1.5 - 巡逻中心策略（重大改进）(2025-11-11)

### ✨ 策略变更
- 🎯 **新思路**：不再禁用AI，而是**修改巡逻中心点**为玩家位置
- ✅ **保留完整AI**：友军保留所有原有行为能力
- ✅ **自然移动**：AI自己控制移动和朝向，不会倒着走
- ✅ **性能更好**：不需要每帧强制控制，代码更简洁

### 🔧 实现细节
```csharp
// 每0.2秒更新一次友军的巡逻中心
UpdateAllyPatrolCenter(ally, playerPos);

// 修改Movement组件的位置字段
homePosition = playerPos;
spawnPosition = playerPos;

// AI会围绕新的中心点巡逻
// 完全不需要禁用组件或强制控制
```

### 💡 使用体验
- ✅ 友军围绕玩家自然移动
- ✅ 自动战斗，自动躲避
- ✅ 不会回原地，一直跟着玩家
- ✅ 移动流畅，符合游戏原生AI风格

### 🎓 学到的经验
- 🧠 **理解AI系统**：不要对抗原有系统，而是引导它
- 🎯 **巧妙的解决方案**：改一个点胜过禁用十个组件
- 💡 **简单就是美**：几行代码解决复杂问题

---

## v1.4 - 友军跟随系统 (2025-11-11)

### ✨ 新功能
- ✅ **友军自动跟随** - 被贿赂的敌人会跟着玩家一起移动，不会回原地
- ✅ **强制朝向控制** - 直接设置角色旋转，避免倒着走
- ✅ **持续AI控制** - 每0.05秒更新一次，持续覆盖原有AI指令
- ✅ **保留战斗能力** - 只禁用移动AI，保留攻击AI
- ✅ **友军列表管理** - 自动管理所有被贿赂的友军
- ✅ **彻底禁用移动AI** - 禁用组件 + 重置位置字段 + 清空路径

### 🔧 实现细节
```csharp
// 1. Update循环中持续更新（每0.05秒，每秒20次）
if (distance > 1.5米) {
    // 强制角色朝向玩家
    character.transform.rotation = Quaternion.LookRotation(direction);
    // 设置移动输入
    ally.SetMoveInput(direction);
} else {
    ally.SetMoveInput(Vector3.zero);  // 太近停下
}

// 2. 禁用移动AI，保留战斗AI
DisableOriginalAI(ally);
// 禁用：Patrol、Guard、Navigation、Waypoint、Movement（AI）
// 保留：Attack、Combat、Shoot、CharacterMovement
// 重置：所有位置字段设为当前位置
// 清空：所有路径数组/列表

// 3. 启用AI搜索目标
NeedToSearchTarget = true;  // 友军会主动攻击敌人
```

### 💡 使用体验
- ✅ 友军会跟着你到处走，**不会倒着走**
- ✅ 友军始终面向玩家方向移动
- ✅ 不会回到出生点或巡逻路线
- ✅ 自动攻击附近的敌人
- ✅ 一直跟随直到死亡

### 🔧 v1.4.1 更新 - 修复倒退问题
- ✅ 添加 `ForceRotateTowards()` 强制设置角色朝向
- ✅ 忽略Y轴高度差，只在2D平面计算方向
- ✅ 将位置字段重置为当前位置（而不是null）
- ✅ 清空路径为空数组（而不是null）

---

## v1.3 - 俯视图游戏适配 (2025-11-11)

### ✨ 新功能
- ✅ **俯视图游戏适配** - 改用距离检测替代射线检测
- ✅ **自动选择最近敌人** - 按E键贿赂范围内最近的敌人
- ✅ **详细调试信息** - 显示玩家位置、附近物体、敌人列表等

### 🔧 改进
- 使用 `Physics.OverlapSphere` 进行距离检测
- 支持多种方式查找玩家对象（Tag、名称、遍历角色）
- 调整贿赂范围为3米（适合俯视图游戏）
- 添加 `debugMode` 开关控制调试输出

### 💡 工作方式
```
玩家靠近敌人 → 按E键 → 自动贿赂最近的敌人
无需瞄准，只需要在范围内
```

---

## v1.2 - 物品ID探索系统 (2025-11-11)

### ✨ 新功能
- ✅ **找到金币ID** - 确认金币物品ID为 **451**
- ✅ **物品ID探索工具** - 添加多个热键测试不同ID范围：
  - F4: 测试ID 1-100
  - F3: 测试ID 100-300
  - F2: 测试ID 300-500
  - F1: 探索玩家金钱系统
  - F8: 查看ItemAssetsCollection结构
  - F7: 显示已知物品列表
- ✅ **物品ID列表文档** - 创建详细的物品ID参考文档

### 🔧 改进
- 更新 `AddTestMoney()` 使用正确的金币ID (451)
- 添加物品ID常量 `ITEM_ID_COIN = 451`
- 完善物品搜索功能

---

## v1.1 - 双重条件系统 (2025-11-11)

### ✨ 新功能
- ✅ **双重条件判断** - 转换敌人需要同时满足两个条件：
  - 贿赂次数 ≥ 2次
  - 累计金额 ≥ 100金币
- ✅ **实时进度显示** - 每次贿赂后显示当前进度和还需多少
- ✅ **详细反馈系统** - 清晰显示还缺少的条件

### 🔧 改进
- 使用 `BribeRecord` 类同时追踪次数和金额
- 优化日志输出，提供更友好的用户反馈
- 更灵活的配置参数

### 📊 配置参数
```csharp
bribePrice = 100;        // 每次100金币
minBribeTimes = 2;       // 至少2次
minTotalAmount = 100;    // 累计≥100金币
bribeRange = 5f;         // 5米范围
```

### 💡 示例场景
```
第1次贿赂：
  贿赂次数: 1/2
  累计金额: 100/100
  还需贿赂 1 次

第2次贿赂：
  贿赂次数: 2/2
  累计金额: 200/100
  ✅ 满足转换条件！
  🎉 敌人转换为友军！
```

---

## v1.0 - 初始版本

### ✨ 核心功能
- ✅ 射线检测敌人
- ✅ 基础贿赂系统
- ✅ 敌人阵营转换
- ✅ 友军判断

### 📝 已知限制
- ⏳ 金钱系统为测试模式
- ⏳ 需要探索游戏金钱API

